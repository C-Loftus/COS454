```{r}
library(purrr)
library(readr)
library(jsonlite)
library("data.table")
library(dplyr)
library(rlist)
setwd("./")
library(magrittr)
```

```{r}

surveyResponseToVal <- jsonlite::fromJSON("data/sleepiness.json")$meta
preprocess <- function(csv, surveyString, isMorning, personID) {
    relevant_data <- csv %>%
        dplyr::filter(trial_type == "two-step-trial") %>%
        select(state_1_choice, transition, outcome) %>%
        dplyr::filter(!grepl("null", state_1_choice)) %>%
        dplyr::filter(!grepl("null", transition)) %>%
        dplyr::filter(!grepl("null", outcome)) %>%
        mutate(next_state1_choice = lead(state_1_choice, 1)) %>%
        mutate(stay = state_1_choice == next_state1_choice) %>%
        mutate(tiredness = surveyResponseToVal[surveyString][[1]]) %>%
        mutate(isMorning = isMorning) %>%
        dplyr::filter(!is.na(next_state1_choice)) %>%
        # mutate(outcome = ifelse(outcome == 0, -1, outcome)) %>%
        # mutate(transition = ifelse(transition == 0, -1, transition)) %>%
        as.data.frame()

    attr(relevant_data, "isMorning") <- isMorning
    attr(relevant_data, "personID") <- personID
    # attr(relevant_data, "tiredness") <- surveyResponseToVal[surveyString][[1]]

    return(relevant_data)
}
```

```{r}

allData <- list()

for (person in list.files("data/")) {
    if (!grepl("json", person)) {
        surveyResponseMap <- jsonlite::fromJSON(paste0("data/", person, "/meta.json"))$meta
        morningFirst <- surveyResponseMap$first == "morning"
        for (csv in list.files(paste0("data/", person, "/"))) {
            if (!grepl("json", csv)) {
                csvIsMorning <- grepl("day", csv)
                if (csvIsMorning && morningFirst | !csvIsMorning && !morningFirst) {
                    surveyResponse <- surveyResponseMap["form1"]
                } else {
                    surveyResponse <- surveyResponseMap["form2"]
                }

                readInCsv <- read_csv(paste0("data/", person, "/", csv))
                processedCSV <- preprocess(readInCsv, surveyResponse[[1]], csvIsMorning, person)
                allData[[length(allData) + 1]] <- processedCSV
            }
        }
    }
}
```

# Create Logistic Regression and Store Coefficients
```{r}
# Logistic Regression Model: Predicting stay (selecting the same stage 1 choice as the previous round)
# based on outcome (rewarded/unrewarded) and transition (common/rare)

logisticRegressionStay <- function(trial_data) {
    stay_pred_mod <- glm(stay ~ outcome * transition, data = trial_data, family = binomial)

    res = append(stay_pred_mod$coefficients, trial_data$tiredness[1])
    names(res) <- c("Intercept", "outcome", "transition", "outcome:transition", "tiredness")
    return(res)
}

morningCoefList <- allData %>%
    list.filter(attr(., "isMorning") == TRUE) %>%
    map(logisticRegressionStay)
eveningCoefList <- allData %>%
    list.filter(attr(., "isMorning") == FALSE) %>%
    map(logisticRegressionStay)

allCoefList <- append(morningCoefList, eveningCoefList)


morningOutcome <- c()
eveningOutcome <- c()
morningTransition <- c()
eveningTransition <- c()
morningInteraction <- c()
eveningInteraction <- c()
morningTiredness <- c()
eveningTiredness <- c()

# pull a specific column for each dataframe in the list
for (i in 1:length(morningCoefList)) {
    morningOutcome <- c(morningOutcome, morningCoefList[[i]][["outcome"]])
    eveningOutcome <- c(eveningOutcome, eveningCoefList[[i]][["outcome"]])
    morningTransition <- c(morningTransition, morningCoefList[[i]][["transition"]])
    eveningTransition <- c(eveningTransition, eveningCoefList[[i]][["transition"]])
    morningInteraction <- c(morningInteraction, morningCoefList[[i]][["outcome:transition"]])
    eveningInteraction <- c(eveningInteraction, eveningCoefList[[i]][["outcome:transition"]])
    morningTiredness <- c(morningTiredness, morningCoefList[[i]][["tiredness"]])
    eveningTiredness <- c(eveningTiredness, eveningCoefList[[i]][["tiredness"]])
}
```

# Check for T Test: # It doesn't follow a normal distribution :/
```{r}
# Check that the difference btwn conditions follows a normal distribution
# via the Shapiro-Wilk normality test
canTestOutcome <- shapiro.test(morningOutcome - eveningOutcome)
canTestTransition <- shapiro.test(morningTransition - eveningTransition)
canTestInteraction <- shapiro.test(morningInteraction - eveningInteraction)
```

```{r}
outcomeResult <- wilcox.test(morningOutcome, eveningOutcome, paired = TRUE)
transitionResult <- wilcox.test(morningTransition, eveningTransition, paired = TRUE)
# p-value = 0.03979 when 0/1
interactionResult <- wilcox.test(morningInteraction, eveningInteraction, paired = TRUE)
```

```{r}
allOutcome <- c(morningOutcome, eveningOutcome)
allTransition <- c(morningTransition, eveningTransition)
allInteraction <- c(morningInteraction, eveningInteraction)
allTiredness <- c(morningTiredness, eveningTiredness)

cor(allOutcome, allTiredness)
cor(allTransition, allTiredness)
cor(allInteraction, allTiredness)
```


```{r}
# Logistic Regression Model: Predicting stay (selecting the same stage 1 choice as the previous round)
# based on outcome (rewarded/unrewarded), transition (common/rare), AND sleepiness score
logisticRegressionStaySleepy <- function(trial_data) {
    stay_pred_mod <- glm(stay ~ tiredness, data = trial_data, family = binomial)
}

sleepyCoefs <- allData %>% map(logisticRegressionStaySleepy)
sleepyCoefs
```