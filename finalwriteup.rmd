```{r}
library(purrr)
library(readr)
library(jsonlite)
library("data.table")
library(dplyr)
library(rlist)
setwd("./")
library(magrittr)
library(lme4)
```

```{r}

surveyResponseToVal <- jsonlite::fromJSON("data/sleepiness.json")$meta
preprocess <- function(csv, surveyString, isMorning, morningFirst, personID) {
    relevant_data <- csv %>%
        dplyr::filter(trial_type == "two-step-trial") %>%
        select(state_1_choice, transition, outcome) %>%
        dplyr::filter(!grepl("null", state_1_choice)) %>%
        dplyr::filter(!grepl("null", transition)) %>%
        dplyr::filter(!grepl("null", outcome)) %>%
        mutate(state_1_choice = as.numeric(state_1_choice)) %>%
        mutate(outcome = as.numeric(outcome)) %>%
        mutate(next_state1_choice = lead(state_1_choice, 1)) %>%
        mutate(stay = state_1_choice == next_state1_choice) %>%
        mutate(tiredness = surveyResponseToVal[surveyString][[1]]) %>%
        mutate(isMorning = isMorning) %>%
        mutate(task_run = ((isMorning && morningFirst) || (isMorning && morningFirst))) %>%
        mutate(isMorning = ifelse(isMorning == TRUE, 1, -1)) %>% # Do in one line with above???
        mutate(task_run = ifelse(task_run == TRUE, 1, -1)) %>% # Do in one line with above???
        mutate(subject = personID) %>%
        dplyr::filter(!is.na(next_state1_choice)) %>%
        mutate(outcome = ifelse(outcome == 0, -1, outcome)) %>%
        mutate(transition = ifelse(transition == 0, -1, transition)) %>% # center around 0
        as.data.frame()

    attr(relevant_data, "isMorning") <- isMorning
    attr(relevant_data, "personID") <- personID
    # attr(relevant_data, "tiredness") <- surveyResponseToVal[surveyString][[1]]

    return(relevant_data)
}
```

```{r}

allData <- list()

for (person in list.files("data/")) {
    if (!grepl("json", person)) {
        surveyResponseMap <- jsonlite::fromJSON(paste0("data/", person, "/meta.json"))$meta
        morningFirst <- surveyResponseMap$first == "morning"
        for (csv in list.files(paste0("data/", person, "/"))) {
            if (!grepl("json", csv)) {
                csvIsMorning <- grepl("day", csv)
                if (csvIsMorning && morningFirst | !csvIsMorning && !morningFirst) {
                    surveyResponse <- surveyResponseMap["form1"]
                } else {
                    surveyResponse <- surveyResponseMap["form2"]
                }

                readInCsv <- read_csv(paste0("data/", person, "/", csv))
                processedCSV <- preprocess(readInCsv, surveyResponse[[1]], csvIsMorning, morningFirst, person)
                allData[[length(allData) + 1]] <- processedCSV
            }
        }
    }
}
```

```{r}
allDataConcat <- bind_rows(allData)
```

# GLMER
```{r}
# Can remove some variables
# random effects: per-subject
# fixed effects: for group
# outcome beta: model-free effect (win-stay, lose-shift effect)
# outcome-transition interaction: model-based effect
# show bar plot for everyone: compute proportions separately for each task run and then
# average proportions together within person and then for entire group
# Q1: is task replicating prior research? report outcome effect and out:trans effect (non-sig trend; in text)
base_reg <- glmer(stay ~ outcome*transition + (1 | subject), data = allDataConcat, family = binomial)
summary(base_reg)
```

# GLMER Controlling for Time of Day
```{r}
# strat to include every var as random effect and then prune higher order rand effects until model converged
# run task run without morning stuff
# make two sets of bar plots (task run 1 and task run 2; morning vs evening)
tod_reg <- glmer(stay ~ outcome*transition*(task_run + isMorning) + (1 | subject), data = allDataConcat, family = binomial)
summary(tod_reg)
```

# GLMER Controlling for Tiredness
```{r}
# Median split plot on the tiredness ratings (take all runs with low tiredness and make plot)
tiredness_reg <- glmer(stay ~ outcome*transition*(task_run + tiredness) + (1 + (outcome*transition) || subject), data = allDataConcat, family = binomial)
summary(tiredness_reg)
```

# Create Logistic Regression and Store Coefficients
```{r}
# Logistic Regression Model: Predicting stay (selecting the same stage 1 choice as the previous round)
# based on outcome (rewarded/unrewarded) and transition (common/rare)

logisticRegressionStay <- function(trial_data) {
    stay_pred_mod <- glm(stay ~ outcome * transition, data = trial_data, family = binomial)

    res = append(stay_pred_mod$coefficients, trial_data$tiredness[1])
    names(res) <- c("Intercept", "outcome", "transition", "outcome:transition", "tiredness")
    return(res)
}

morningCoefList <- allData %>%
    list.filter(attr(., "isMorning") == TRUE) %>%
    map(logisticRegressionStay)
eveningCoefList <- allData %>%
    list.filter(attr(., "isMorning") == FALSE) %>%
    map(logisticRegressionStay)

allCoefList <- append(morningCoefList, eveningCoefList)


morningOutcome <- c()
eveningOutcome <- c()
morningTransition <- c()
eveningTransition <- c()
morningInteraction <- c()
eveningInteraction <- c()
morningTiredness <- c()
eveningTiredness <- c()

# pull a specific column for each dataframe in the list
for (i in 1:length(morningCoefList)) {
    morningOutcome <- c(morningOutcome, morningCoefList[[i]][["outcome"]])
    eveningOutcome <- c(eveningOutcome, eveningCoefList[[i]][["outcome"]])
    morningTransition <- c(morningTransition, morningCoefList[[i]][["transition"]])
    eveningTransition <- c(eveningTransition, eveningCoefList[[i]][["transition"]])
    morningInteraction <- c(morningInteraction, morningCoefList[[i]][["outcome:transition"]])
    eveningInteraction <- c(eveningInteraction, eveningCoefList[[i]][["outcome:transition"]])
    morningTiredness <- c(morningTiredness, morningCoefList[[i]][["tiredness"]])
    eveningTiredness <- c(eveningTiredness, eveningCoefList[[i]][["tiredness"]])
}
```

# Check for T Test: # It doesn't follow a normal distribution :/
```{r}
# Check that the difference btwn conditions follows a normal distribution
# via the Shapiro-Wilk normality test
canTestOutcome <- shapiro.test(morningOutcome - eveningOutcome)
canTestTransition <- shapiro.test(morningTransition - eveningTransition)
canTestInteraction <- shapiro.test(morningInteraction - eveningInteraction)
```

```{r}
outcomeResult <- wilcox.test(morningOutcome, eveningOutcome, paired = TRUE)
transitionResult <- wilcox.test(morningTransition, eveningTransition, paired = TRUE)
# p-value = 0.03979 when 0/1
interactionResult <- wilcox.test(morningInteraction, eveningInteraction, paired = TRUE)
```

```{r}
allOutcome <- c(morningOutcome, eveningOutcome)
allTransition <- c(morningTransition, eveningTransition)
allInteraction <- c(morningInteraction, eveningInteraction)
allTiredness <- c(morningTiredness, eveningTiredness)

cor(allOutcome, allTiredness)
cor(allTransition, allTiredness)
cor(allInteraction, allTiredness)
```


```{r}
# Logistic Regression Model: Predicting stay (selecting the same stage 1 choice as the previous round)
# based on outcome (rewarded/unrewarded), transition (common/rare), AND sleepiness score
logisticRegressionStaySleepy <- function(trial_data) {
    stay_pred_mod <- glm(stay ~ tiredness, data = trial_data, family = binomial)
}

sleepyCoefs <- allData %>% map(logisticRegressionStaySleepy)
sleepyCoefs
```